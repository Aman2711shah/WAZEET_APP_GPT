// Firestore Security Rules for WAZEET App
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is owner of document
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'super_admin'];
    }
    
    // Helper function to check if user is super admin
    function isSuperAdmin() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin';
    }
    
    // Public read for freezones catalog
    // Used by FreeZoneService and FreezoneBrowserPage for browsing free zones
    match /freezones/{pkgId} {
      allow read: if true;
      allow write: if isAdmin(); // Only admins can modify freezones
      match /promos/{promoId} {
        allow read: if true;
        allow write: if isAdmin();
      }
    }
    
    // User profiles - read if discoverable or own profile, write only own profile
    match /users/{uid} {
      allow read: if isAuthenticated() && (
        resource.data.isDiscoverable == true || 
        isOwner(uid) ||
        isAdmin() // Admins can read all profiles
      );
      allow create: if isOwner(uid);
      allow update: if (isOwner(uid) && (
        !('preferences' in request.resource.data) || 
        request.resource.data.preferences is map
      ) && 
        // Prevent users from self-promoting to admin
        (!('role' in request.resource.data) || request.resource.data.role == resource.data.role)
      ) || (
        // Allow admins to update user roles
        isAdmin() && 
        (!('role' in request.resource.data) || 
          (request.resource.data.role in ['user', 'moderator', 'admin']) ||
          (isSuperAdmin() && request.resource.data.role == 'super_admin')
        )
      );
      allow delete: if false; // Prevent direct deletion - use Cloud Function
      
      // User preferences subcollection
      match /preferences/{prefId} {
        allow read, write: if isOwner(uid);
      }
      
      // User activity subcollection
      match /activity/{activityId} {
        allow read, write: if isOwner(uid);
      }
      
      // User notifications subcollection
      match /notifications/{notificationId} {
        allow read, write: if isOwner(uid);
      }
    }
    
    // Connections - read/write only by connection participants
    match /connections/{connectionId} {
      allow read: if isAuthenticated() && (
        request.auth.uid == resource.data.a || 
        request.auth.uid == resource.data.b
      );
      allow create: if isAuthenticated() && (
        request.auth.uid == request.resource.data.a || 
        request.auth.uid == request.resource.data.b
      );
      allow update: if isAuthenticated() && (
        request.auth.uid == resource.data.a || 
        request.auth.uid == resource.data.b
      );
    }
    
    // Connection requests - read only by recipient
    match /connection_requests/{uid}/requests/{otherUid} {
      allow read: if isOwner(uid);
      allow write: if isAuthenticated();
    }
    
    // User edges (for mutual connections) - read by anyone, write by owner
    match /user_edges/{uid}/accepted/{otherUid} {
      allow read: if isAuthenticated();
      allow write: if isOwner(uid);
    }
    
    // Discovered events - read by all authenticated users
    match /discoveredEvents/{eventId} {
      allow read: if isAuthenticated();
      allow write: if false; // Only Cloud Functions can write
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'super_admin'];
    }
    
    // Service requests - RBAC & schema invariants
    function isServiceOwner() {
      return isAuthenticated() && request.auth.uid == request.resource.data.userId;
    }
    function hasStandardTier() { return request.resource.data.tier == 'standard'; }
    function hasCustomTier() { return request.resource.data.tier == 'custom'; }
    function isValidServiceRequest() {
      // Exactly one branch populated based on tier
      return isServiceOwner() && (
        (hasStandardTier() && ('packageDetails' in request.resource.data) && !('companySetupData' in request.resource.data)) ||
        (hasCustomTier() && ('companySetupData' in request.resource.data) && !('packageDetails' in request.resource.data))
      );
    }
    match /service_requests/{requestId} {
      // Creation must satisfy owner + tier branch exclusivity
      allow create: if isValidServiceRequest();
      // Get single doc if owner or admin
      allow get: if isAuthenticated() && (isAdmin() || resource.data.userId == request.auth.uid);
      // Listing collection restricted to admins (prevents enumeration of user submissions)
      allow list: if isAuthenticated() && isAdmin();
      // Updates restricted to admins (users cannot alter submitted data)
      allow update: if isAuthenticated() && isAdmin();
      // Direct deletes disabled; retention/anonymization handled by scheduled functions
      allow delete: if false;
    }
    
    // Freezone packages - read by all, write by admin
    match /freezone_packages/{packageId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Freezone packages (camelCase collection name) - read by all, write by admin
    match /freezonePackages/{packageId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // AI conversations - users can only access their own
    match /ai_conversations/{conversationId} {
      allow read, write: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated();
      
      // Messages within conversations
      match /messages/{messageId} {
        allow read, write: if isAuthenticated() && 
          get(/databases/$(database)/documents/ai_conversations/$(conversationId)).data.userId == request.auth.uid;
      }
    }
    
    // Community posts - read by all authenticated, write by author
    match /posts/{postId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.visibility == 'public';
      allow update: if isAuthenticated() && 
        resource.data.authorId == request.auth.uid;
      allow delete: if false; // Use moderation flow instead
      
      // Post comments subcollection
      match /comments/{commentId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && 
          request.resource.data.authorId == request.auth.uid &&
          request.resource.data.text is string &&
          request.resource.data.text.size() > 0;
      }
      
      // Post likes subcollection
      match /likes/{userId} {
        allow read, create, delete: if isAuthenticated() && 
          request.auth.uid == userId;
      }
    }
    
    // User profiles collection (for community posts author metadata)
    match /profiles/{uid} {
      allow read: if isAuthenticated();
      allow create, update: if isAuthenticated() && request.auth.uid == uid;
      allow delete: if false;
    }
    
    // Admin audit log - only admins can read, system can write
    match /admin_audit_log/{logId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated(); // RoleService creates entries
      allow update, delete: if false; // Immutable log
    }
  }
}
